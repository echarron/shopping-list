<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Shopping-list by pvardanega</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>TP sur les tests automatisés et l'intégration continue.</h1>
          <h2>Comment développer de nouvelles fonctionnalités en répondant aux besoins, sans générer de régression ?</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/pvardanega/shopping-list" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <!-- INTRODUCTION-->
          <h3><a id="intro" class="anchor" href="#intro" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>

          <p>Ce TP va se dérouler en 3 parties :</p>

          <ul>
            <li>récupérer les sources du projet et les brancher sur l'intégration continue,</li>
            <li>développer une nouvelle fonctionnalité,</li>
            <li>la déployer automatiquement dans le cloud.</li>
          </ul>

          <p>Afin de pouvoir réaliser ce TP dans de bonnes conditions, il vous faut créer des comptes sur les services suivant :</p>

          <ul>
            <li><a href="http://www.github.com" target="_blank">github</a> : service d'hébergement et de versionning de code source,</li>
            <li><a href="http://www.codeship.com" target="_blank">codeship</a> : service permettant de réaliser des traitements d'intégration continue,</li>
            <li><a href="http://www.heroku.com" target="_blank">heroku</a> : service d'hébergement d'applications.</li>
          </ul>

          <p>Github et Heroku nécessite que vous configuriez une clé SSH. Si vous n'en avez pas, suivez ce <a href="https://help.github.com/articles/generating-ssh-keys/"
            target="_blank">tutorial</a>. Ensuite, ajouter votre clé <strong>publique</strong> dans les paramètres de vos comptes.</p>

          <!-- SET UP CONTINUOUS INTEGRATION -->
          <h3><a id="ic" class="anchor" href="#ic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configurer l'intégration continue</h3

          <p>Notre objectif pour cette étape est de récupérer les sources du projet et de configurer un job d'intégration continue qui va compiler et exécuter
            nos tests unitaires, d'intégration et de comportement.</p>

          <h4>Récupération des sources du projet</h4>

          <p>Connectez-vous à github et allez sur la <a href="https://github.com/pvardanega/shopping-list" target="_blank">page du projet</a>. Puis "forker" le
            projet. Ceci aura pour action de "copier" le projet dans votre compte github.</p>

          <p>Ensuite, depuis une console, exécuter les commandes suivantes (en remplacer your_login par la bonne valeur) :<p>

          <pre><code>$ git clone git@github.com:your_login/shopping-list.git
$ cd shopping-list</code></pre>

          <p>Vous êtes à la racine du projet. Celui-ci est structuré avec <a href="http://maven.apache.org/" target="_blank">maven</a> afin de pouvoir compiler
            et exécuter les tests simplement. Pour valider que tout fonctionne, exécuter la commande suivante :</p>

          <pre><code>$ mvn clean compile</code></pre>

          <p>Vous devez obtenir un message de réussite :</p>

          <pre><code>[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building shopping-list 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ shopping-list ---
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ shopping-list ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /Users/pvardanega/dev/sources/shopping-lists-master/src/main/resources
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ shopping-list ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 6 source files to /Users/pvardanega/dev/sources/shopping-lists-master/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.930 s
[INFO] Finished at: 2015-02-17T17:17:53+01:00
[INFO] Final Memory: 17M/170M
[INFO] ------------------------------------------------------------------------</code></pre>

          <p>Le projet compile, tout va bien !</p>

          <h4>Exécution des tests</h4>

          <p>Ce projet contient déjà quelques fonctionnalités. Elles sont testées mais pour s'assurer que le code correspond aux besoins, nous allons exécuter tous
          les tests.</p>

          <h5>Tests unitaires</h5>

          <p>Nous allons lancer les tests unitaires en exécutant la commande suivante :</p>

          <pre><code>$ mvn clean test</code></pre>

          <p>Vous devez obtenir un message de réussite :</p>

          <pre><code>[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building shopping-list 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[...]
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ shopping-list ---
[INFO] Surefire report directory: /Users/pvardanega/dev/sources/shopping-lists-master/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running fr.xebia.shoppinglist.users.UserRepositoryTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.074 sec
Running fr.xebia.shoppinglist.users.UsersResourceTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.373 sec

Results :

Tests run: 4, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- jasmine-maven-plugin:1.3.1.5:test (default) @ shopping-list ---
[...]
-------------------------------------------------------
 J A S M I N E   S P E C S
-------------------------------------------------------
[INFO]
Create account controller
  it should initiate AccountCreationCtrl
  should send account creation to backend

My account controller
  it should initiate MyAccountCtrl
  it should create one new shopping list

Application routes
  should map routes to controllers

Results: 5 specs, 0 failures
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.619 s
[INFO] Finished at: 2015-02-17T21:59:43+01:00
[INFO] Final Memory: 29M/275M
[INFO] ------------------------------------------------------------------------</code></pre>

          <h5>Tests d'intégration</h5>

          <p>Nous allons lancer les tests d'intégration en exécutant la commande suivante :</p>

          <pre><code>$ mvn clean verify -Pit</code></pre>

          <p>Vous devez obtenir un message de réussite :</p>

          <pre><code>[...]
-------------------------------------------------------
T E S T S
-------------------------------------------------------
Running fr.xebia.shoppinglist.it.shoppinglists.NewListsIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.772 sec - in fr.xebia.shoppinglist.it.shoppinglists.NewListsIT
Running fr.xebia.shoppinglist.it.users.NewAccountIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.064 sec - in fr.xebia.shoppinglist.it.users.NewAccountIT

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
[...]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 11.156 s
[INFO] Finished at: 2015-02-17T22:44:36+01:00
[INFO] Final Memory: 39M/211M
[INFO] ------------------------------------------------------------------------</code></pre>

          <h5>Tests de comportement</h5>

          <p>Nous allons lancer les tests de comportement en exécutant la commande suivante :</p>

          <pre><code>$ mvn clean verify -Pat</code></pre>

          <p>Vous devez obtenir un message de réussite :</p>

          <pre><code>[...]
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running fr.xebia.shoppinglist.it.shoppinglists.NewListsIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.772 sec - in fr.xebia.shoppinglist.it.shoppinglists.NewListsIT
Running fr.xebia.shoppinglist.it.users.NewAccountIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.064 sec - in fr.xebia.shoppinglist.it.users.NewAccountIT

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
[...]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 11.156 s
[INFO] Finished at: 2015-02-17T22:44:36+01:00
[INFO] Final Memory: 39M/211M
[INFO] ------------------------------------------------------------------------</code></pre>


          <p>C'est super, tous nos tests sont verts. Malheureusement, c'est un peu laborieux de lancer les tests manuellement avant chaque commit/push sur github.
             Pour éviter cela, nous allons créer un job d'intégration continue qui s'en chargera à notre place.</p>

          <h4>Configurer un job d'intégration continue</h4>

          <p>Connectez-vous sur codeship pour créer un nouveau job d'intégration continue.</p>

          <img src="images/codeship-create-new-project.png"/>

          <p>Ensuite, il faut que codeship puisse accéder aux sources du projet afin de pouvoir les récupérer pour exécuter des
            actions.</p>

          <img src="images/codeship-select-sources-on-github.png"/>

          <p>Choisissez votre projet puis configurer le job pour qu'il compile les sources et exécute les test unitaires.</p>

          <img src="images/codeship-setup-job.png"/>

          <p>Sauvergarder puis modifier le fichier <code>README.md</code> (ajouter une ligne vide), committer et pusher sur master.</p>

          <p>Observer l'exécution du job :</p>

          <img src="images/codeship-first-build.png" />

          <p>Modifier la configuration des tests du job en ajoutant l'exécution des tests d'intégration.</p>

          <img src="images/codeship-add-it.png"/>

          <p>Et relancer un build. Les test doivent passer.</p>

          <img src="images/codeship-start-new-build.png"/>

          <p>Enfin, faites de même avec les tests de comportement.</p>

          <!-- ADD ONE NEW FEATURE -->
          <h3><a id="new_feature" class="anchor" href="#new_feature" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nouvelle fonctionnalité</h3>

          <p>Nous allons développer la fonctionnalité permettant d'ajouter des produits à une liste.</p>

          <h4>Ajouter une test de comportement</h4>

          <p>Ajouter un scénario de test dans la fichier <code>shopping-list.feature</code></p>

          <pre><code>Scenario:
  Given Claire, an existing user
  And she creates a new list with title 'Romantic dinner'
  When she adds 'candels' in the list 'Romantic dinner'
  Then the list 'Romantic dinner' contains the product 'candels'</code></pre>

          <p>Puis implémenter les steps dans la classe <code>ShoppingListStepdefs.java</code> :</p>

          <pre><code>@When("^she adds '(.*)' in the list '(.*)'$")
public void she_adds_candels_in_the_list(String product, String listTitle) throws Throwable {
    new WebDriverWait(webDriver, SECONDS.toSeconds(1L)).until(presenceOfElementLocated(className("shopping-list")));
    webDriver.findElement(linkText(listTitle)).click();
    assertThat(webDriver.findElement(id("products"))).isNotNull();

    webDriver.findElement(id("newProduct")).sendKeys(product);
    webDriver.findElement(id("btnAddProduct")).click();
}

@Then("^the list '(.*)' contains the product '(.*)'$")
public void the_list_contains_the_product_candels(String listTitle, String product) throws Throwable {
    assertThat(webDriver.findElement(id("products"))).isNotNull();
    assertThat(webDriver.findElement(xpath("(//h3)[1]")).getText()).isEqualTo(listTitle + " (1)");
    assertThat(webDriver.findElements(className("product"))).hasSize(1);
    WebElement existingProduct = webDriver.findElements(className("product")).get(0);
    assertThat(existingProduct.getText()).isEqualTo(product);
}</code></pre>

          <p>Enfin, exécuter les tests de comportement qui doivent être en échec.</p>

          <h4>Développer la vue</h4>

          <p>Créer la vue <code>list.html</code> dans le répertoire <code>views</code> :</p>

          <pre><code>&lt;div>
    &lt;div class="row">
        &lt;h3>{{list.title}} ({{list.products.length}})&lt;/h3>
    &lt;/div>
    &lt;div class="row">
        &lt;div class="col-sm-4">
            &lt;div class="input-group">
                &lt;input type="text" class="form-control" id="newProduct" ng-model="newProduct" placeholder="Add product" required>
                &lt;span class="input-group-btn">
                    &lt;button class="btn btn-primary" type="button" id="btnAddProduct" ng-click="addProductToList()">Add product&lt;/button>
                &lt;/span>
            &lt;/div>
        &lt;/div>
    &lt;/div>
    &lt;div class="row">
        &lt;ul id="products">
            &lt;li class="product" ng-repeat="product in list.products" value="{{product}}">{{product}}&lt;/li>
        &lt;/ul>
    &lt;/div>
&lt;/div></code></pre>

          <p>Afin quelle soit accessible, il nous faut :</p>

          <ul>
            <li>configurer une route permettant d'y accéder,</li>
            <li>définir un lien qui pointerait vers cette page.</p>
          </ul>

          <h5>Définition de la route</h5>

          <p>Nous allons modifier le fichier <code>app.js</code> qui contient la définition des routes. Pour celà, nous allons
            d'abord modifier le test validant les routes dans le fichier <code>routesSpec.js</code> en ajoutant les deux assertions
            suivantes :</p>

          <pre><code>expect($route.routes['/lists/:listId'].templateUrl).toEqual('views/list.html');
expect($route.routes['/lists/:listId'].controller).toEqual('listCtrl');</code></pre>

          <p>Relancer les tests unitaires :</p>

          <pre><code>$ mvn jasmine:test</code></pre>

          <p>Le test sur les routes devrait échouer.</p>

          <p>Modifier le fichier <code>app.js</code> et ajouter la route :</p>

          <pre><code>when('/lists/:listId', {
    templateUrl: 'views/list.html',
    controller: 'listCtrl'
}).</code></pre>

          <p>On y définie l'URL pour accéder à la page, le template html ainsi que le contrôleur qui gère le contenu de la vue.</p>

          <p>Relancer les tests unitaires :</p>

          <pre><code>$ mvn jasmine:test</code></pre>

          <p>Le test sur les routes devrait passer.</p>

          <h5>Appeler cette page depuis une autre page</h5>

          <p>Nous allons maintenant pouvoir afficher le détail d'une liste de courses en cliquant sur son nom.</p>

          <p>Modifier l'affichage des listes de courses (fichier <code>me.html</code>) :</p>

          <pre><code>&lt;div class="row">
    &lt;ul>
        &lt;li class="shopping-list" ng-repeat="list in myShoppingLists" value="{{list.id}}">
            &lt;a href="#/lists/{{list.id}}">{{list.title}}&lt;/a>
        &lt;/li>
    &lt;/ul>
&lt;/div></code></pre>

          <h4>Développer le contrôleur en TDD</h4>

          <p>Nous allons créer le contrôleur <code>listCtrl.js</code> en commençant par les tests. Son rôle est de faire le lien en
          la vue et le serveur.</p>

          <h5>Ajout d'un test unitaire</h5>

          <p>Créer le fichier <code>src/test/javascript/listControllerSpec.js</code> :</p>

          <pre><code>'use strict';

describe('Manage list controller', function() {

    var httpBackend,
        scope,
        ctrl,
        param,
        list = {id: 1, title: "MyList", products: ["milk", "eggs", "pastas"]};

    beforeEach(module('shopping-list'));

    beforeEach(inject(function(_$httpBackend_, $rootScope, $controller, $routeParams) {
        httpBackend = _$httpBackend_;
        scope = $rootScope.$new();
        param = $routeParams;
        param.listId = 12;
        ctrl = $controller('listCtrl', {$scope: scope});
        httpBackend.whenGET('/api/users/1/lists/12').respond(200, list);
    }));

    it('it should initiate ListCtrl', function() {
        httpBackend.flush();

        expect(scope.list).toEqual(list);
        expect(scope.newProduct).toBeDefined();
    });
});</code></pre>

          <p>Ce test permet de valider l'instanciation du contrôleur. Vous pouvez remarquer qu'on teste qu'un appel au serveur
            est bien effectué et que la liste retournée par le serveur est bien stockée dans la variable <code>list</code>.</p>

          <p>Relancer les tests unitaires :</p>

          <pre><code>$ mvn jasmine:test</code></pre>

          <p>Le test du contrôleur devrait échouer.</p>

          <h5>Implémentation du controleur la plus simple possible pour faire passer le test</h5>

          <p>Créer le fichier <code>src/main/webapp/js/listCtrl.js</code> :</p>

          <pre><code>shoppingList.controller('listCtrl', [ '$scope', '$http', '$routeParams', function($scope, $http, $routeParams) {
    $scope.newProduct = "";
    $scope.list = {};

    $http.get('/api/users/1/lists/' + $routeParams.listId)
        .success(function (data) {
            $scope.list = data;
        })
    ;
}]);</code></pre>

          <p>L'inclure dans l'application (modifier le fichier <code>index.html</code>) :</p>

          <pre><code>&lt;script src="js/listCtrl.js">&lt;/script></code></pre>

          <p>Ainsi que dans la configuration du plugin jasmine de maven (modifier le fichier <code>pom.xml</code>) :</p>

          <pre><code>&lt;sourceIncludes>
  &lt;include>app.js&lt;/include>
  &lt;include>accountCreation.js&lt;/include>
  &lt;include>myAccount.js&lt;/include>
  &lt;include>listCtrl.js&lt;/include>
&lt;/sourceIncludes></code></pre>

          <p>Relancer les tests unitaires :</p>

          <pre><code>$ mvn jasmine:test</code></pre>

          <p>Le test du contrôleur devrait passer.</p>

          <h5>Ajouter un test qui permet d'ajouter un produit à la liste</h5>

          <pre><code>it('should add a product and notify the server', inject(function() {
    scope.newProduct = "salad";
    httpBackend
        .whenPOST('/api/users/1/lists/12/products', scope.newProduct)
        .respond(201, scope.newProduct);

    scope.addProductToList();

    httpBackend.flush();
    httpBackend.expectPOST('/lists/12/products');
    expect(scope.list.products).toContain("salad");
    expect(scope.newProduct).toBe("");
}));</code></pre>

          <p>Implémentation :</p>

          <pre><code>$scope.addProductToList = function () {
    $http.post('/api/users/1/lists/' + $routeParams.listId + '/products', $scope.newProduct)
        .success(function (data) {
            $scope.newProduct = "";
            $scope.list.products.push(data);
        }
    );
};</code></pre>

          <p>Relancer les tests unitaires :</p>

          <pre><code>$ mvn jasmine:test</code></pre>

          <p>Le test du contrôleur devrait passer. À cette étape, la vue et le contrôleur sont développés et testés
          selon nos besoin et de la manière la plus simple possible. Maintenant, passons à la partie serveur.</p>

          <h4>Ajouter un test d'intégration qui va tester l'ajout d'un produit</h4>

          <p>Nous allons maintement nous concentrer sur la partie serveur en commençant par créer un test d'intégration.</p>

          <p>Créer la classe <code>AddProductIT.java</code> qui va ajouter un produit à une liste d'un utilisateur :</p>

          <pre><code>public class AddProductIT {

    @Test public void
    should_add_one_product_to_a_list() {
        given().
                body(new User("test@test.fr", "norman", "password")).
                contentType(JSON).
        when().
                post("/api/users").
        then().
                statusCode(201)
        ;

        given().
                body("Romantic dinner").
                contentType(JSON).
        when().
                post("/api/users/1/lists").
        then().
                statusCode(201)
        ;

        given().
                body("Salad").
                contentType(JSON).
        when().
                post("/api/users/1/lists/1/products").
        then().
                statusCode(200).
                body(equalTo("Salad"))
        ;

        given().
                contentType(JSON).
        when().
                delete("/api/users/1").
        then().
                statusCode(200)
        ;
    }
}</code></pre>

          <p>Si vous lancez les tests d'intégration, ils doivent échouer.</p>

          <h4>Implémenter la ressource en TDD</h4>

          <p>Passons maintenant à l'implémentation de ce test. Nous allons d'abord créer notre ressource REST qui réceptionnera les
            requêtes venant du contrôleur javascript.</p>

          <p>Pour celà, ajoutons un test dans la classe UsersResourceTest.java :</p>

          <pre><code>@Test public void
should_add_one_product_to_a_list() {
    // Given
    Long userId = 54321L;
    Long listId = 132L;

    User expectedUser = new User(userId, "test@test.fr", "test", "password", Lists.newArrayList(new ShoppingList(listId, "Romantic dinner")));
    given(userRepository.get(userId)).willReturn(expectedUser);

    // When
    Response response = resource.addProductToList(userId, listId, "Salad");

    // Then
    assertThat(response.getStatus()).isEqualTo(OK.getStatusCode());
    assertThat(response.getEntity()).isEqualTo("Salad");
}</code></pre>

          <p>Puis implémenter la fonctionnalité :</p>

          <pre><code>@Path("{userId}/lists/{listId}/products")
@POST
public Response addProductToList(@PathParam("userId") Long userId,
                                 @PathParam("listId") Long listId,
                                 String product) {
    User user = userRepository.get(userId);
    for (ShoppingList list : user.lists) {
        if (listId.equals(list.id)) {
            list.addProduct(product);
        }
    }
    return Response.
            ok().
            entity(product).
            build()
            ;
}</code></pre>

          <p>La méthode <code>addProduct</code> n'existant pas, créez-la en la laissant vide.</p>

          <p>Relancer les tests unitaires, ils doivent passer.</p>

          <p>Maintenant, nous allons tester puis implémentater la méthode <code>addProduct</code>. Pour se faire, créer la classe
            <code>ShoppingListTest.java</code> et ajouter un test validant que la liste contient bien un produit après l'avoir ajouté :</p>

          <pre><code>@Test public void
should_add_a_product_to_the_list() {
    ShoppingList list = new ShoppingList(1234L, "MyList");

    list.addProduct("Salad");

    assertThat(list.products).hasSize(1).containsExactly("Salad");
}</code></pre>

          <p>Enfin, implémentez-la :</p>

          <pre><code>public void addProduct(String product) {
    this.products.add(product);
}</code></pre>

          <p>Relancer les tests unitaires et d'intégration, seuls les tests unitaires doivent passer. En effet, nous venons de
          modifier une classe qui a des conséquences sur un autre test d'intégration. Corriger et relancer les relancer les tests
          d'intégration. Ils doivent passer.</p>

          <h4>Ajouter un test d'intégration qui va tester la récupérer d'une liste d'un utilisateur</h4>

          <p>Nous allons utiliser la même méthode que pour l'ajout d'un produit à une liste. Commencer par créer
            la classe <code>RetrieveListIT.java</code> :</p>

          <pre><code>public class RetrieveListIT {

    @Test public void
    should_add_one_product_to_a_list() {
        given().
                body(new User("test@test.fr", "norman", "password")).
                contentType(JSON).
        when().
                post("/api/users").
        then().
                statusCode(201)
        ;

        given().
                body("Romantic dinner").
                contentType(JSON).
        when().
                post("/api/users/1/lists").
        then().
                statusCode(201)
        ;

        given().
                contentType(JSON).
        when().
                get("/api/users/1/lists/1").
        then().
                statusCode(200).
                body(matchesJsonSchemaInClasspath("schemas/list.json")).
                body("id", equalTo(1)).
                body("title", equalTo("Romantic dinner")).
                body("products", emptyIterable())
        ;

        given().
                contentType(JSON).
        when().
                delete("/api/users/1").
        then().
                statusCode(200)
        ;
    }
}</code></pre>

          <p>Si vous lancez les tests d'intégration, ils doivent échouer.</p>

          <h4>Implémenter la ressource en TDD</h4>

          <p>Passons maintenant à l'implémentation de ce test. Nous allons d'abord créer notre ressource REST qui réceptionnera les
            requêtes venant du contrôleur javascript.</p>

          <p>Pour celà, ajoutons un test dans la classe <code>UsersResourceTest.java</code> :</p>

          <pre><code>@Test public void
should_retrieve_a_list() {
    // Given
    Long userId = 54321L;
    Long listId = 132L;

    ShoppingList expectedList = new ShoppingList(listId, "Romantic dinner");
    User expectedUser = new User(userId, "test@test.fr", "test", "password", Lists.newArrayList(expectedList));
    given(userRepository.get(userId)).willReturn(expectedUser);

    // When
    Response response = resource.retrieveList(userId, listId);

    // Then
    assertThat(response.getStatus()).isEqualTo(OK.getStatusCode());
    assertThat(response.getEntity()).isEqualTo(expectedList);
}</code></pre>

          <p>Puis implémenter la fonctionnalité :</p>

          <pre><code>@Path("{userId}/lists/{listId}")
@GET
public Response retrieveList(@PathParam("userId") Long userId,
                             @PathParam("listId") Long listId) {
    User user = userRepository.get(userId);
    for (ShoppingList list : user.lists) {
        if (listId.equals(list.id)) {
            return Response.
                    ok().
                    entity(list).
                    build()
                    ;
        }
    }
    return Response.
            status(NOT_FOUND).
            build()
            ;
}</code></pre>

          <p>Relancer les tests unitaires, d'intégration et de comportement, ils doivent passer.</p>

          <h4>Committer et pusher la fonctionnalité</h4>

          <p>Committer les modifications puis les pusher sur la branche master de la remote <code>origin</code>.</p>

          <p>Enfin, observer l'exécution du job, les tests doivent passer.</p>

          <!-- DEPLOY ON HEROKU -->
          <h3><a id="deploy" class="anchor" href="#deploy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Déployer l'application dans le cloud</h3>

          <p>Dans cette partie, nous allons tout d'abord créer une "application" sur heroku qui se chargera d'héberger notre code source.</p>

          <h4>Création de l'instance qui hébergera notre application</h4>

          <p>Se connecter sur le site <a href="https://dashboard.heroku.com/new" target="_blank">heroku.com</a> et créer une nouvelle application.</p>

          <img src="images/heroku-create-app.png"/>

          <p>Ensuite, revenir dans le répertoire source de votre projet puis ajouter une "remote" à la configuration git et pusher le code source sur cette remote :</p>

          <pre><code>$ git remote add heroku git@heroku.com:shopping-list.git
$ git push heroku master</code></pre>

          <p>Le résultat doit être le suivant :</p>

          <pre><code>Fetching repository, done.
Counting objects: 25, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (21/21), done.
Writing objects: 100% (25/25), 3.62 KiB | 0 bytes/s, done.
Total 25 (delta 8), reused 0 (delta 0)

-----> Java app detected
-----> Installing OpenJDK 1.7... done

[...]

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 6.941 s
[INFO] Finished at: 2015-02-18T16:07:01+00:00
[INFO] Final Memory: 30M/649M
[INFO] ------------------------------------------------------------------------
-----> Discovering process types
Procfile declares types -> web

-----> Compressing... done, 102.1MB
-----> Launching... done, v9
https://shopping-list.herokuapp.com/ deployed to Heroku</code></pre>

          <p>Enfin, ajouter un worker à l'application, ce qui correspond à une unité de calcul. Ceci alloura de la mémoire et du CPU à votre application.</p>

          <img src="images/heroku-add-worker.png"/>

          <h4>Automatisation du déploiement</h4>

          <p>Nous allons faire en sorte que chaque changement réalisé sur notre application soit déployé automatiquement lorsqu'un build se termine en succès.</p>

          <p>Tout d'abord, connectez-vous sur codeship, sélectionner le projet et cliquer sur "Project settings" puis "Deployment". C'est dans cet écran que nous allons
            configurer le déploiement de notre application sur heroku.</p>

          <p>Sélectionner Heroku comme étant notre hebergeur :</p>

          <img src="images/codeship-select-heroku.png" />

          <p>Ensuite, remplissez les informations demandées :</p>

          <img src="images/codeship-setup-heroku.png" />

          <p>La configuration est terminée ! Lors du prochain succès du job, l'application sera automatiquement déployée sur heroku.</p>

          <img src="images/codeship-deployment-setup.png" />

          <p>Afin de valider le déploiement, nous allons modifier le fichier <code>README.md</code> pour afficher le bon status de l'intégration continue.
            Commiter les changements et observer la dernière étape qui concerne le déploiement. Votre application doit toujours être déployée.</p>

          <p>Pour cela, aller dans le menu "Notifications" des "Project settings" et copier/coller les informations.</p>

          <img src="images/github-add-codeship-status.png" />

          <p>Vous devez aussi observer un logo codeship de couleur grise, verte ou rouge (en fonction du résultat de la dernière exécution du job)
            sur la page principale de votre projet github.</p>

          <h3>Conclusion</h3>

          <p>Vous avez vu toutes les étapes pour ajouter une nouvelle fonctionnalité en ajoutant des tests,
            la tester puis la déployer automatiquement. En suivant cette démarche, vous êtes capable de faire
            évoluer votre application au fil de l'eau sans attendre plusieurs semaines/mois avant de mettre en production.</p>

        </section>

        <footer>
          Shopping-list is maintained by <a href="https://github.com/pvardanega">pvardanega</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

      </div>
    </div>
  </body>
</html>
